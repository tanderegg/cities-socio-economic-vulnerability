library(shiny)
library(tidyr)
library(tidyverse)
library(dplyr)
library(readr)
library(vroom)
library(data.table)
library(leaflet)
library(leaflet.extras)
library(sf)
library(httr)
library(jsonlite)
library(geojsonsf)
library(glue)
library(shinyFeedback)

# read census variables definition
census_variables_definition = read.csv("https://cities-socio-economic-vulnerability.s3.eu-west-3.amazonaws.com/mexico/census/census_variables_definition.csv",
                                       fileEncoding="UTF-8-BOM")

census_variables_group = unique(census_variables_definition$variable_category)

# Define UI for application 
ui <- navbarPage("Census Dashboard",
                 # Mexico Tab ----
                 tabPanel("Mexico",
                          useShinyFeedback(),
                          
                          fluidRow(
                            # select entity level
                            column(3,
                                   selectizeInput(
                                     "entity_level",
                                     "Geographic Level:",
                                     choices = c("State", "Municipality", "Block")
                                   )), 
                            
                            # select group of variable
                            column(3,
                                   selectizeInput(inputId = "variable_group",
                                                  label = "Census variable theme:",
                                                  choices = census_variables_group,
                                                  selected = census_variables_group[1],
                                                  multiple = FALSE)
                            ),
                            
                            # select variable
                            column(3,
                                   selectizeInput(inputId = "variable",
                                                  label = "Census variable:",
                                                  # choices = NULL,
                                                  choices = c("d_dwg"),
                                                  # selected = "d_dwg",
                                                  multiple = FALSE)
                            ),
                            
                            # select year
                            column(3,
                                   selectizeInput(inputId = "year",
                                                  label = "Year:",
                                                  choices = 2020,
                                                  selected = 2020,
                                                  multiple = FALSE)
                            ),
                            
                            # select state
                            column(4,
                                   selectizeInput(inputId = "state_name",
                                                  label = "State:",
                                                  choices = c("All"),
                                                  # selected = unique(geo_levels_names$state_name)[1],
                                                  selected = "All",
                                                  multiple = FALSE)
                            ),
                            
                            
                            column(4,
                                   selectizeInput(inputId = "municipality_name",
                                                  label = "Municpality:",
                                                  choices =  NULL,
                                                  multiple = FALSE)
                            ),

                          ),
                          
                          # Create a new row for the table.
                          # DT::dataTableOutput("table"),
                          column(6,
                                 DT::dataTableOutput("table"),
                                 downloadButton(outputId = "downloadData", 
                                                label = "Download Tabular data")
                          ),
                          column(6,
                                 leafletOutput("census_map", 
                                               height = 600),
                                 downloadButton(outputId = "downloadGeoData", 
                                                   label = "Download Geospatial data")
                          )
                          
                 ),
                 # Brazil Tab ----
                 tabPanel("Brazil"),
                 # Colombia Tab ----
                 tabPanel("Colombia"),
                 # India Tab ----
                 tabPanel("India")
)



# Define server 
server <- function(input, output, session) {
  
  # Query MX State API
  state_data <- reactive({
    mx_state_query <-
      "https://data-api.globalforestwatch.org/dataset/wri_mexico_state_socio_economic_vulnerability/v2020/query"
    query_compact <- query_fields()
    res <- GET(mx_state_query, query = query_compact)
    res_content <- fromJSON(content(res, as = "text", encoding = "UTF-8"))$data
    bind_rows(res_content)
  })
  
  # Query MX Municipality API
  muni_data <- reactive({
    mx_muni_query <-
      "https://data-api.globalforestwatch.org/dataset/wri_mexico_municipality_socio_economic_vulnerability/v2020.2/query"
    query_compact <- query_fields()
    res_muni <- GET(mx_muni_query , query = query_compact)
    res_content <- fromJSON(content(res_muni, as = "text", encoding = "UTF-8"))$data
    bind_rows(res_content)
  })
  
  # Query MX Block API
  block_data <- reactive({
    # mx_block_api <-
    #   "https://data-api.globalforestwatch.org/dataset/wri_mexico_block_socio_economic_vulnerability/v2020.1/query"
    # query_compact <- query_fields()
    # where_query <-
    #   paste(
    #     query_compact,
    #     glue(
    #       "WHERE state_name = '{input$state_name}' AND municipality_name = '{input$municipality_name}'"
    #     )
    #   )
    # block_query <- list(sql = where_query)
    # res_block <- GET(mx_block_api, query = block_query)
    # res_content <-
    #   fromJSON(content(res_block, as = "text", encoding = "UTF-8"))$data
    # bind_rows(res_content)
    mx_block_api <-
      "https://data-api.globalforestwatch.org/dataset/wri_mexico_block_socio_economic_vulnerability/v2020.1/query"
    
    query_compact <-
      "SELECT gfw_fid, entity_level, municipality_id, municipality_name, locality_id, locality_name, block_id, d_dwg, d_1rm, d_prop_1rm, d_2rms, d_prop_2rms, d_3mrms, d_prop_3mrms, d_mean_occup_r, d_1bedrm, d_prop_1bedrm, d_2mbedrms, d_prop_2mbedrms, d_dirtfloor, d_prop_dirtfloor, d_ntoil, d_prop_ntoil, d_ndrng, d_prop_ndrng, d_npwater, d_prop_npwater, d_nelect, d_prop_nelect, d_nbs, d_prop_nbs, d_ninet, d_prop_ninet, d_ncmp, d_prop_ncmp, d_ncp, d_prop_ncp, d_ntv, d_prop_ntv, d_nict, d_prop_nict, d_ncar, d_prop_ncar, d_mtrcl, d_prop_mtrcl, d_nmovh, d_prop_nmovh, d_bike, d_prop_bike, d_nrefri, d_prop_nrefri, d_nwm, d_prop_nwm, d_ngoods, d_prop_ngoods, p_tot, p_tot_m, p_tot_f, p_prop_m_f, p_0to2, p_0to2_f, p_0to2_m, p_3to5, p_3to5_f, p_3to5_m, p_6to11, p_6to11_f, p_6to11_m, p_12to14, p_12to14_f, p_12to14_m, p_15to17, p_15to17_f, p_15to17_m, p_18to24, p_18to24_f, p_18to24_m, p_25to59, p_25to59_f, p_25to59_m, p_60m, p_60m_f, p_60m_m, p_prop_tdr, p_prop_chddr, p_prop_olddr, p_mean_chdba, p_nhealth, p_prop_health, p_ilit, p_prop_ilit, p_ilit_f, p_prop_ilit_f, p_ilit_m, p_prop_ilit_m, p_6to11nas, p_prop_6to11nas, p_6to11nas_f, p_prop_6to11nas_f, p_6to11nas_m, p_prop_6to11nas_m, p_12to14nas, p_prop_12to14nas, p_12to14nas_f, p_prop_12to14nas_f, p_12to14nas_m, p_prop_12to14nas_m, p_15to17nas, p_prop_15to17nas, p_15to17nas_f, p_prop_15to17nas_f, p_15to17nas_m, p_prop_15to17nas_m, p_18to24nas, p_prop_18to24nas, p_18to24nas_f, p_prop_18to24nas_f, p_18to24nas_m, p_prop_18to24nas_m, p_mean_yredu, p_mean_yredu_f, p_mean_yredu_m, p_emp, p_emp_f, p_emp_m, p_unem, p_unem_f, p_unem_m, p_prop_emp, p_prop_emp_f, p_prop_emp_m, p_econia, p_econia_f, p_econia_m, p_hh, p_hh_f, p_prop_hh_f, p_hh_m, p_prop_hh_m, p_langindig, p_langindig_f, p_langindig_m, p_disab, p_disab_mtr, p_disab_vis, state_name, state_id, gfw_geojson, gfw_bbox FROM result"
    
    # Construct WHERE {state_name} AND {municipality_name}"
    where_query <-
        paste(
          query_compact,
          glue(
            "WHERE state_name = '{input$state_name}' AND municipality_name = '{input$municipality_name}'"
          )
        )
    
    # Get total count of blocks per WHERE query
    count_where <-
      paste(
        "SELECT COUNT(gfw_fid) FROM result",
        glue(
          "WHERE state_name = '{input$state_name}' AND municipality_name = '{input$municipality_name}'"
        )
      )
    count_query <- list(sql = count_where)
    
    api_count <- GET(mx_block_api, query = count_query)
    res_count <- fromJSON(content(api_count, "text"))$data[[1]]
    print("Number of blocks")
    print(res_count)
    # Construct initial query
    offset <- 0
    initial_page <- list(sql = where_query, offset = offset, limit = 1000)
    resp <- GET(mx_block_api, query = initial_page)
    res_content <-
      fromJSON(content(resp, as = "text", encoding = "UTF-8"))$data
    payload <- content(resp)
    while(offset < res_count) {
      print(res_count - offset)
      print("records left")
      offset <- offset + 1000
      nextPage <- list(sql = where_query, offset = offset)
      resp <- GET(mx_block_api, query = nextPage)
      payload <- fromJSON(content(resp, as = "text", encoding = "UTF-8"))$dat
      data <- append(res_content, payload)
    }
    print("Offset complete")

    bind_rows(data)
    
  }) %>% bindCache(input$state_name, input$municipality_name)
  
  # Create query that excludes geom, geom_wm, and other unused fields
  query_fields <- reactive({
    mx_fields <-
      "https://data-api.globalforestwatch.org/dataset/wri_mexico_municipality_socio_economic_vulnerability/v2020.2/fields"
    fields_res <- GET(mx_fields)
    variable_names <- fromJSON(content(fields_res, as = "text", encoding = "UTF-8"))$data$field_name
    exclude_variables <-
      c(
        "gfw_fid",
        "cvegeo",
        "cve_ent",
        "cve_mun",
        "nomgeo",
        "cvempo",
        "cve_sun",
        "sun_label",
        "tipo_cd",
        "year",
        "ageb_id",
        "geom",
        "geom_wm",
        "gfw_area__ha",
        "gfw_geostore_id",
        "created_on",
        "updated_on"
      )
    variable_names <- variable_names[! variable_names %in% exclude_variables]
    variable_query <- paste0(variable_names, collapse=", ")
    
    list(sql = glue("SELECT {variable_query} FROM result"))
  })
  
  observe({
    # Populate initial state names and census variables
    mx_state_names <- unique(state_data()$state_name)
    updateSelectizeInput(session, "state_name", choices = c("All", mx_state_names))
    
    # TODO Query Census variable groups
    # Currently there is no relation between variable groups and variables in the API.
    
    # Query Census variable fields
    # Census variables are retrievable from field names in state API.
    # Trims non-variable fields from response
    # TODO Currently in API, "field_description": null. 
    # This needs to be populated with descriptions to replace field names.
    mx_fields <-
      "https://data-api.globalforestwatch.org/dataset/wri_mexico_municipality_socio_economic_vulnerability/v2020.2/fields"
    fields_res <- GET(mx_fields)
    variable_names <- fromJSON(content(fields_res, as = "text", encoding = "UTF-8"))$data$field_name
    not_census <-
      c(
        "gfw_fid",
        "cvegeo",
        "cve_ent",
        "cve_mun",
        "nomgeo",
        "cvempo",
        "cve_sun",
        "sun_label",
        "tipo_cd",
        "year",
        "entity_level",
        "municipality_id",
        "state_name",
        "municipality_name",
        "locality_id",
        "locality_name",
        "ageb_id",
        "block_id",
        "geom",
        "geom_wm",
        "gfw_area__ha",
        "gfw_geostore_id",
        "gfw_geojson",
        "gfw_bbox",
        "created_on",
        "updated_on"
      )
    variable_names <- variable_names[! variable_names %in% not_census]
    
    updateSelectizeInput(session, "variable", choices = variable_names)
  })
  
  # Load data table based on census variable input
  observeEvent({input$entity_level
    input$variable  
    input$state_name
    input$municipality_name}, {
      
      # render data table
      render_table <- reactive({
        data_filtered_table = data_filtered %>%
          as.data.frame()
        
        output$table <- DT::renderDataTable(DT::datatable(
          data_filtered_table,
          filter = 'top',
          options = list(
            paging = TRUE,
            pageLength = 10,
            scrollX = TRUE,
            scrollY = TRUE,
            autoWidth = TRUE,
            server = FALSE
          )
        ))
        
        # output data to download ----
        output$downloadData <- downloadHandler(
          filename = function() {
            paste("data-", Sys.Date(), ".csv", sep = "")
          },
          content = function(file) {
            write.csv(data_filtered_table, file)
          }
        )
      })
      
      # filter data for data table
      switch(input$entity_level,
             "State" = {
               if (input$state_name == "All") {
                 data_filtered = state_data() %>%
                   select("entity_level", "state_name", input$variable)
                 render_table()
               } else {
                 data_filtered = state_data() %>%
                   filter(state_name == input$state_name) %>%
                   select("entity_level", "state_name", input$variable)
               }
             }, 
             "Municipality" = {
               if (input$state_name == "All") {
                 data_filtered = muni_data() %>%
                   select("entity_level",
                          "state_name",
                          "municipality_name", 
                          input$variable)
               }  else if (input$municipality_name == "All") {
                 data_filtered = muni_data() %>%
                   filter(state_name == input$state_name) %>%
                   select(state_name,
                          municipality_name,
                          input$variable)
               }
               else {
                 data_filtered = muni_data() %>%
                   filter(state_name == input$state_name,
                          municipality_name == input$municipality_name) %>%
                   select("entity_level",
                          "state_name",
                          "municipality_name",
                          input$variable)
               }
             }, 
             "Block" = {
               state_not_all <- input$state_name != "All"
               feedbackWarning("state_name",!state_not_all, "Please select a state")
               muni_not_all <- input$municipality_name != "All"
               feedbackWarning("municipality_name", !muni_not_all, "Please select a municipality")
               req(input$state_name != "All" && input$municipality_name != "All")
               data_filtered = block_data() %>%
                 select("entity_level", "municipality_name", "block_id", input$variable)
               }
             )
      render_table()
    })
  
  # Load map based on census variable input
  # TODO Change from direct input$variable to tail of multiselect vector
  observeEvent({input$entity_level
    input$variable
    input$state_name
    input$municipality_name}, {
      switch(input$entity_level,
             "State" = {    # Load map for state
               if (input$state_name == "All") {
                 data_filtered = state_data() %>%
                   select(state_name, input$variable, geometry = gfw_geojson)
                 geodata_filtered = geojson_sf(data_filtered[['geometry']])
               } else {
                 data_filtered = state_data() %>%
                   filter(state_name == input$state_name) %>%
                   select(state_name, input$variable, geometry = gfw_geojson)
                 geodata_filtered = geojson_sf(data_filtered[['geometry']])
               }
             }, 
             "Municipality" = {
               # Load map for municipality
               if (input$state_name == "All") {
                 data_filtered = muni_data() %>%
                   select(state_name,
                          municipality_name,
                          input$variable,
                          geometry = gfw_geojson)
                 geodata_filtered = geojson_sf(data_filtered[['geometry']])
               } 
               else if (input$municipality_name == "All") {
                 data_filtered = muni_data() %>%
                   filter(state_name == input$state_name) %>%
                   select(state_name,
                          municipality_name,
                          input$variable,
                          geometry = gfw_geojson)
                 geodata_filtered = geojson_sf(data_filtered[['geometry']])
               } else {
                 data_filtered = muni_data() %>%
                   filter(state_name == input$state_name,
                          municipality_name == input$municipality_name) %>%
                   select(state_name,
                          municipality_name,
                          input$variable,
                          geometry = gfw_geojson)
                 geodata_filtered = geojson_sf(data_filtered[['geometry']])                 
               }
             }, 
             "Block" = {
               req(input$state_name != "All" && input$municipality_name != "All")
               
               data_filtered = block_data() %>%
                   select(input$variable, geometry = gfw_geojson)
                 geodata_filtered = geojson_sf(data_filtered[['geometry']])
             }
      )
    
    # map
    output$census_map <- renderLeaflet({
      leaflet(geodata_filtered) %>%
        addTiles() %>% 
        # addPolygons(data = data_filtered) %>% 
        fitBounds(~as.numeric(st_bbox(geodata_filtered)[1]),
                  ~as.numeric(st_bbox(geodata_filtered)[2]),
                  ~as.numeric(st_bbox(geodata_filtered)[3]),
                  ~as.numeric(st_bbox(geodata_filtered)[4]))
    })
    
    census_variable_values = data_filtered %>%
      as.data.frame() %>%
      pull(input$variable)
    
    # define pal
    pal_census <- colorNumeric("RdYlBu",
                               census_variable_values,
                               na.color = "transparent",
                               reverse = TRUE)
    # define labels information
    labels_census <- sprintf("<strong>%s</strong> %s <br/><strong>%s:</strong> %s <br/><strong>%s:</strong> %s<br/><strong>%s:</strong> %s",
                             "State",input$state_name,
                             "Census variable", input$variable,
                             # "Census variable", selected_variable,
                             "Value", census_variable_values,
                             "Level", input$entity_level) %>%
      lapply(htmltools::HTML)
    
    # plot map ----
    leafletProxy(mapId = "census_map", data = geodata_filtered)  %>%
      clearControls() %>%
      clearShapes() %>%
      # polygons ----
    addPolygons(
      data = geodata_filtered,
      group = "census-var",
      fillColor = ~ pal_census(census_variable_values),
      weight = 1,
      opacity = 1,
      color = "grey",
      fillOpacity = 0.9,
      label = labels_census,
      highlightOptions = highlightOptions(
        color = "black",
        weight = 2,
        bringToFront = FALSE
      ),
      labelOptions = labelOptions(
        style = list("font-weight" = "normal", padding = "3px 6px"),
        textsize = "15px",
        direction = "auto"
      )
    ) %>%
      # legend ----
    addLegend(
      pal = pal_census,
      values = census_variable_values,
      opacity = 0.9,
      # title = input$variable,
      title = input$variable,
      group = "census-var",
      position = "topright",
      labFormat = labelFormat(suffix = "")
    ) %>%
      # Layers control ----
    addLayersControl(overlayGroups = c("census-var"),
                     options = layersControlOptions(collapsed = FALSE)) %>%
      #hideGroup(c("Administrative boundaries")) %>%
      addFullscreenControl()
    
    # Download geospatial data
    geo_data = st_sf(data.frame(data_filtered, geom=geodata_filtered))
    
    output$downloadGeoData <- downloadHandler(
      filename = function() {
        paste("data-", Sys.Date(), ".geojson", sep = "")
      },
      content = function(file) {
        st_write(geo_data, file, driver = "GeoJSON")
      }
    )
  })
  
  # Populate municipality names based on state selection
  observeEvent({
    req(input$entity_level == "Municipality")
    input$state_name
  },
  {if(input$state_name != "All") {
    updateSelectizeInput(session,
                         "municipality_name",
                         choices = c("All", unique(muni_data()[muni_data()$state_name==input$state_name, "municipality_name"])),
                         selected = "All")
  } else {(input$state_name == "All")
    updateSelectizeInput(session,
                         "municipality_name",
                         choices = c("All", unique(muni_data()$municipality_name)),
                         selected = "All")
  }
  })
  
  observeEvent(req(input$state_name), {
    updateSelectizeInput(session,
                         'municipality_name',
                         choices = c("All", unique(muni_data()[muni_data()$state_name==input$state_name, "municipality_name"])),
                         selected = "All"

    )

  })
  
  # User selects Block entity level
  observeEvent(req(input$entity_level == "Block"), {
    # Query MX Block
    mx_block_query <-
      "https://data-api.globalforestwatch.org/dataset/wri_mexico_block_socio_economic_vulnerability/v2020.1/query"
    query_block_id <-
      # times out without a limit on the request WILL NEED TO UPDATE!!
      list(sql = "SELECT block_id FROM result LIMIT 50") 
    res <- GET(mx_block_query, query = query_block_id)
    res_content <- content(res, as = "parsed")$data
    mx_block_tb <- bind_rows(res_content)
    
    mx_block_ids <- unique(mx_block_tb$block_id)
    
    updateSelectizeInput(
      session,
      "block",
      label = "Block:",
      choice = c("All", mx_block_ids)
    )
    
  })
}

# Run the application 
shinyApp(ui = ui, server = server)
